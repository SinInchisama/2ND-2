알고리즘의 첫걸음.
알고리즘의 단어의 유래 
최초의 알고리즘은 최대공약수 알고리즘


알고리즘 - 문제를 해결하기 위한 단계적인 절차를 의미 (요구사항 분석은 제대로, 해야할일은 못할수도, 안해도되는 일을 할 수도 있음.)

무엇을 한것인지 알고 나면 어떻게 할 것인지 생각.

,알고리즘은 요리법과 유사 단계적인 절차를 따라하면 요리가 만들어지듯이, 알고리즘도 단계적인 절차를 따라 하면 주어진 문제의 해를 찾는다.

효율적인 알고리즘 고안이 중요 - 주어진 문제에 대해 여러 종류의 알고리즘이 있을 수 있으나, 보다 효율적인 것을 고민하는 것이 매우 중요


최대 숫자 찾기 -> 순차 탐색 (한 장씩 순서대로 읽어가며 찾아보는 방법)
	           오름차순으로 정렬 되있으면? 바이너리 서치로 찾을 수 있다. 근데 순차 탐색으로 하는 방법은 정렬 유무 차이.
바이너리 서치 -> 절반으로 나누면서 비교하는 방식, log(n)의 속도


동전 거스름돈 -> 대부분의 나라의 동전이 그리드 방식으로 해결할 수 있도록 만들어져있다.
	          그리디 방식이란 - 많이 잡을 수 있는 거는 많이 잡고간다. ex) 750원이면 500원짜리 1개 100원짜리 2개 50원짜리 1개로.


한붓 그리기 -> 	어떤 점에 도착해서. 갈 수 있는 곳으로 가는데 2개이상이면 싸이클이 되는 곳으로 간다., (현재 점에서 현재점으로 올 수 있는 길로)
		오일러 서킷문제와 같다. 사이클이 존재하면 진행한다.


미로 찾기 - 모든 경우의 수를 다 찾아 보는 방법. 가장 단순하고 무식한 방법.(백 트랩 방식)
	   오른손 법칙. 현위치에서 한방향으로 오른벽에 손을 대고 쭉 가는 방법.



가짜 동전 찾기 -> 	어떤 알고리즘을 선택하는지에 따라 속도가 달라진다.
	           	계속 바꾸는 방법 Big(n), 반씩 올려두는 방법 Big(logn) 최선의 경우엔 계속 바꾸는 방법이 더 빠름. 하지만 알고리즘은 평균이나 최악을 말하는게 더 현명함.
		똑같은 big(logn)이라 할지라도 생략된 밑에 분모가 더 클 수 록 더 빠르다.


독이 든 술단지 -> 2진수로 생각하여 문제해결가능. 8개면 신하 3명으로.		 







Chapter 2
알고리즘의 일반적 특성 -
정확성 - 알고리즘은 주어진 입력에 대해 올바른 해를 주어야함.(랜덤 제외)
수행성 - 알고리즘의각단계는컴퓨터에서 수행가능해야
유한성 - 알고리즘은 유한시간내에 종료되어야
효율성 - 효율적일수록 그 가치가 높아진다.


최초의 알고리즘 - 유클리드의 최대 공약수 알고리즘.
2개의 자연수의 최대공약수는 큰 수 에서 작은수를 뺀 것과 같다?
뺼셈 대신 나눗셈을 사용하면 더 빨리 구할 수 있다.


알고리즘의 표현 방법 - 알고리즘의 형태는 단계절 절차이므로, 마치 요리책의 요리를 만드는 절차와 유사.
일반적으로 알고리즘은 프로그래밍 언어와 유사한 의사코드로 표현
알고리즘의 각 단계는 보통 말로 서술할 수 있으며, 컴퓨터 프로그래밍 언어로만 표현할 필요는 없음.

의사코드 - 자연어로 작성하는 방법 (아무나 이해할 수 있지만, 사용해야 되는 단어가 너무 많다.)
	 플로우 차트
              의사 코드


알고리즘의 분류 - 분할정복 알고리즘, 그리디 알고리즘, 동적 계획 알고리즘, 근사 알고리즘(해를 구할 수 없음.), 백트래킹 알고리즘, 분기한정 알고리즘

문제에 기반
특정 환경에 기반



알고리즘의 효율성 - 알고리즘의 수행시간 또는 알고리즘이 수행하는 동안 사용되는 메모리크기로 나타낼수있음 (시간 복잡도, 공간 복잡도) 보통은 시간 복잡도가 사용됨.



최악의 경우	: 어떤 입력이 주어지더라도 알고리즘의 수행시간이 얼마 이상은 넘지 않는다. 상한의 의미
평균의 경우
최선 경우



시간복잡도는 입력 크기에 대한 함수로 표기 ( 점근 적 표기를 사용)
점근적 표기  O(Big-Oh) 표기 , 오메가(Big-Omega)표기, 세타(Theta) 표기 -> 학계에서는 빅오와 세타를 구분하지만 업계에서는 세타 내용으로  big 오로 표기한다.
빅오 표기법 - 다항식에서 최고 차수 항만을 정한뒤 최소 차수만 나타낸다(상수없이)		-> 과제로 한 거 보기

O(1) 상수시간, O(logn) 로그시간,O(n) 선형시간,O(nlogn) 로그선형시간,O(n^2) 이차시간,O(n^3) 3차시간,O(n^k) 다항식시간,O(2^n) 지수시간
n^2 nlogn 차이와 n과 logn차이가 비슷하다. 왼쪽꺼가 오른쪽꺼보다 항상 빠르다는 것을 잘못됐다. 대체적으로 빠른것이다.



정렬 알고리즘
내부 정렬 - 입력의 크기가 주기억장치의 공간보다 크지 않은 경우에 수행되는 정렬. ex) 버블 ,선택,삽입,합병,퀵,힙,쉘,기수,이중피봇,Tim
퀵소트의 최약의 경우 n^2임 근데 n^2으로 안가게 막아놓는 코드들이 많아서 nlogn으로 판단
같은 값이 있을 떄 바꿀 수 있으면 안정 아니면 불안정.		6분짜리 알고리즘 봐보기(씨X)
외부정렬  - 중간고사 이후



버블 정렬 - 이웃하는 숫자를 비교하여 작은 수를 앞쪽으로 이동시키는 과정을 반복하여 정렬
장점 구현하기 쉽다.
최선 N 최악 n^2


선택 정렬 - 최솟값을 선택해서 왼쪽 맨끝으로 보낸다?
입력이 거의 정렬되어 있뜬지, 역으로 정렬되어있든지 랜덤하게 되어있든지 항상 일정한 시간복잡도를 나타낸다.
이별에 민감하지않은 알고리즘, 원소간의 자리바꿈 횟수가 최소인 정렬


삽입 정렬
배열을 정렬된 부분과 정렬안된 부분으로 나눈고 정렬 안된 부분의 가장 왼쪽 원소를 정렬된 부분의 적절한 위치에 삽입하여 정렬
어떻게 진행되는지 잘 이해하고 구현할수도 있게끔 하기.
이미 정렬되어있으면 O(n) 아니면 O(n^2)
삽입 정렬은 거의 정렬된 입력에 대해서 다른 정렬알고리즘보다 빠르다. 입력의 크기가 작을 때 매우 좋은 성능을 보임



버블 정렬이나 삽입 정렬이 수행되는 과정 - 기껏해야 이웃된 것들을 바꿈
쉘 정렬 - 갭이란 것을 두어 빠르게 비교하여 이동하게 하는 방법. 갭은 서서히 줄어듬.
	코드 한번 봐볼까? 고민해보자.
	갭이 1이면 삽입 정렬과 동일.
	시간 복잡도는 아직 풀리지 않은 문제. 가장 좋은 간격을 알아내야 하는 것이 선행되어야 하기 때문
	

힙정렬 - 	힙 조건을 만족하는 완전 이진 트리(힙 조건 각 노드의 우선 순위가 자식 노드의 우선 순위보다 높다.)
	최대 힙 - 가장 큰 값이 루트에 저장. 최소 힙 - 가장 작은 값이 루트에 저장.
N개의 노드를 가진힙. 완전이진 트리이므로 힙의 높이가 log2N이면 노드들을 빈공간없이 배열에 저장

	정렬할 입력로 최대 힙으로 만든다.
	힙 루트에 가장 큰 수가 있으므로, 루트와 힙의 가장 마지막 노드를 교환한다.
	힙의 크기를 1개 줄인다.
	루트에 새로 저장된 숫자로 인해 위배된 힙 조건을 해결하여 힙조건을 만족시킨다.
	이떄 정렬이 아닌 힙조건만 충족하는 이유는 속도의 차이때문.

DownHeap() 루트로부터 자식들 중에서 큰 값을 가진 자식과 비교하여 힙 속성이 만족될 때까지 숫자를 교환하여 이파리 방향으로 진행.
g힙만드는 데 O(n)시간 데이터 팝 for루프는(n-1) DownHeap은 O(logn) = O(nlogn)
최선 최악 평균시간복잡도가 O(nlogn)으로 동일.너무많은 데이터에서 Downheap을 수행할때 자식을 찾아야 하므로 너무 많은 캐시미스로 인해 페이지 부재를 야기시킴

선택 정렬 안정성x
삽입정렬 O
쉘 정렬 x
힙정렬 x
퀵정렬 x
tim sort o

힙정렬이 머지보다 퀵보다 느린 이유는 캐시미스때문에 머지가 퀵보다 느린이유는 추가적인 메모리를 사용해서



비교 정렬 - 기수정렬은 비교정렬이 아님.
결정 트리를 만들어보자. 각 내부 노드에서는 2개의 숫자가 비교, 비교 결과가 참이면 왼쪽으로 거짓이면 오른쪽으로 분기, 각 이파리에는 정렬된 결과 저장.

log(n!) = O(nlogn)이므로 비교 정렬의 하한은 O(nlogn) 즉 O(nlogn)보다 빠를 수없다. 비교정렬은.



기수 정렬. 카운트 소트를 안하는이유. 메모리가 많이 사용되기때문에. 따라서 가지수가 얼마 안될 때 사용할 수 있다.
기수정렬은 제한적인 범위내에있는 숫자에 대해서 각 자릿수 별로 정렬하는 알고리즘.
for 루프가 k번 반복.
루프가 1회 수행될때 n개의 숫자의 i자리수를 일그염, r개로 분류하여 개수를 세고, 그 결과에따라 숫자가 이동하므로 O(n+r)시간이 소모됨
시간복잡도는 O(k(n+r)), k나 r이 입력 크기인 n보다 크지 않으면, 시간 복잡도는 O(n)

1의 자리부터 k까지 lsd 기수 정렬 k부터 1의 자리까지 msd 기수 정렬
	


분할 정복 알고리즘.
주어진 문제의 입력을 분할하여 문제를 해결하는 방식의 알고리즘.

문제가 2개로 분할되고 부분 문제의 크기가 일정하지 않은 크기로 감소하는 알고리즘 - 퀵정렬


합병정렬??????????????????
분할 정렬 합병
시간복잡도 O(nlogn) 공간복잡도 O(n)


퀵 정렬
분할하고 문제를 풀고 다시 합치는 과정이 없음. 분할되고나면 다시 합칠 필요가없다. 그래서 정복후 분할이라는 표현을 쓰기도 한다.
피봇을 잘 설정해서 피봇보다 작은건 왼쪽 큰거는 오른쪽으로 보낸다.
1. 파티션, 2. 결정된 피봇의 왼쪽 퀵소트 3. 오른쪽 퀵소트
이떄 피봇은 분활된 왼편이나 오른편 부분에 포함되지 않음.
퀵정렬의 최악 경우 시간 복잡도는 O(n^2) 최선의 경우 O(nlogn) 평균시간도  O(nlogn)

랜덤하게 설정할 경우 반씩 안 갈릴 수도 있음. 정렬된거에서 맨 왼쪽거를 선택하면 하나씩밖에 줄어들지않는다.
Median - of- Medians 3등분한 후 각 부분에서 가장 왼쪽 숫자, 중간 숫자, 가장 오른쪽 숫자중에서 중앙값을 찾은 후, 세중앙값들 중에서 중앙값을 피봇을 정한다.
성능향상 방법. 입략의 크기가 매우 클 때, 퀵 정렬의 성능을 더 향상시키기 위해 합병정렬과 같이 사용.



선택 문제
선택 알고리즘은 분할 정복 알고리즘이기도 랜덤 알고리즘이기도 하다.
작은쪽이 4분의 1보다 작으면 나쁨, 아니면 좋은 분할.
평균 경우  O(n) 좋은 분할만계속되면,



최근접 점의 쌍 찾기
O(n^2)보다 효율적인 분할 정복 이용.
취합할때 중간영역을 고려해야함.
중간영역안의 점들. 10,15중에서 짧은 거리인 10이내의 중간 영역안에 있는 점들 중에 더 근접한 점의 쌍이 있는지 확인해야함.
각층의 수행시간은 O(nlogn)       시간복잡도(nlog^2n)


분할정복의 주의할점.
피보나치 수 처럼 분할하고 난후에 더 늘어날수도 있다.
입력이 분할될때마다 분활된 부분 문제들의 입력 크기의 합이 분할되기전의 입력크기보다 커지는 경우이다. 또 하나 주의해야 할 요소는 취합(정복)과정이다.


