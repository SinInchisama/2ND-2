1.  Knight's Tour (knight's move) 가 무엇인지 조사하라. 최대한 많은 정보를 조사하기로 한다.

Knight's Tour는 기사가 모든 보드판을 정확히 한번씩만 방문하도록하는 체스판 위의 Knight의 움직임입니다.
Knight's Tour 문제는 Knight's Tour찾는 수학적 문제이고, Knight's Tour을 찾는 프로그램은 컴공과 학생들에게 주어지는 일반적인 문제입니다.
Knight's Tour는 해밀턴 경로 문제의 예 중 하나입니다.
Knight's Tour는 2가지의 풀이법이 있는데 하나는 마지막으로 이동한 칸이 맨처음 위치했던 칸으로 이동하여 어느 사각형에 있든 항상 동일한 경로로 통과할 수 있는 Closed Knight's Tour
와 최종 위치와 처음 위치가 같지 않은 Open Knight's Tour가 있습니다.
Knight's Tour를 찾는 방법은 여러 가지 방법이 있다.
Brute-force algorithms, Divide-and-conquer algorithms, Warnsdorff's rule, Neural network solutions가 있습니다.


2. Knight's Tour 의 해를 찾기 위한 프로그램을 개발하기로 했는데, Back-Tracking 기법을 사용하기로 했다.

2-1. 이 기법을 사용하여 해를 구하는 것을 pseudo code 를 사용하여 기술해 보라

if( 움직임 == 보드판 크기^2)
	종료

for i = 0 to 8{
	x = x + Movex[i];
	y = y + Movey[i];

	if  보드판[x][y] != 0 && 보드판 밖으로 나가지 않는다면
	보드판[x][y] =
}

2-2. 이때 예상되는 실행 시간은 얼마인가? 하나의 길을 가 보는 것을 1 단위시간이라고 했을 때 대략적으로 얼마에 가까운 단위시간이 필요한가?
Knight가 움직일 수 있는 방법은 총 8가지고 n*n 보드판이라 했을때 걸리는 시간의 최악은 8^n^2이다.
Knight's Tour는 보통 8*8 보드판에서 진행하므로 8^64만큼 걸린다

2-3. 수퍼컴퓨터가 1초에 1억 단위시간을 처리할 수 있다고 가정하면 (그런 컴퓨터는 현재 기술상 없지만) 이 컴퓨터로 이 문제를 해결하는 데 얼마의 시간이 걸리는가?
6.2771017353866807638357894232077e+49만큼 걸린다.



3. 정렬 방법에는 다양한 알고리즘이 있다.

3-1. 최대한 많은 알고리즘에 대해 조사하고 각 알고리즘의 시간 성능을 Big-O notation 을 이용하여 표시하라.
1. 선택정렬 - 선택된 값과 나머지 데이터중에 비교하여 알맞은 자리를 찾는 알고리즘   Big-O notation => BO(n^2)
2. 삽입정렬 - 데이터 집합을 순회하면서 정렬이 필요한 요소를 뽑아내어 이를 다시 적당한 곳으로 삽입하는 알고리즘 	  Big-O notation => BO(n^2)
3. 버블정렬 - 인접한 두 수를 비교하여 오름차순이나 내림차순으로 정렬하는 방식   Big-O notation => BO(n^2)
4. 병합정렬 - 둘 이상의 부분집합으로 가르고, 각 부분집합을 정렬한 다음 다음 부분집합들을 다시 정렬된 형태로 합치는 방식   Big-O notation => BO(n log n)
5. 힙정렬 - 트리 기반으로 내림차순 정렬을 위해서는 최대 힙 구성하고 오름차순 정렬을 위해서는 최소 힙을 구성하여 정렬하는 방식  Big-O notation => BO(n log n)
6. 퀵정렬 - 데이터 집합내에 임의의 기준값을 정하고 해당 기준값으로 집합을 기준으로 두개의 부분 집합으로 나누어 한쪽부분에는 기준값보다 작은값들만 다른 한쪽은 큰값들만 넣어 쪼갤 부분 집합이 없을때까지 각각의 부분 집합에 대해 피벗/쪼개기 재귀적으로 적용하는 방식   Big-O notation => BO(n log n)
7. 기수정렬 - 낮은 자리수부터 비교해가며 정렬하는 방식   Big-O notation => BO(dn)
8. 트리 정렬 - 이진 탐색 트리를 이용하여 정렬하는 방식으로 중위 순회 방법을 사용하여 정렬한다.  Big-O notation => BO(n log n)
9. 팀 정렬 - 병합과 삽입이 합쳐진 정렬으로 대부분 이미 정렬되어 있을 것이란 가정하에 파이썬을 위해 만들어진 정렬 Big-O notation => BO(n log n)
10. 셸 정렬 - 삽입 정렬을 띄엄띄엄한 간격으로 먼저 수행하고, 그 간격을 점차 좁혀나가면서 최종적으로 거의 정렬된 배열을 삼입정렬로 마무리하는 방식   Big-O notation => BO(n^2)
11. 보고 정렬 - 랜덤으로 데이터들을 재배열한후 될 때까지 랜덤으로 재배열하는 방식    Big-O notation => BO(Infinite)


3-2. https://www.youtube.com/watch?v=kPRA0W1kECg 를 보고 영상의 각 부분이 의미하는 바를 정리하라. 화면상에 나타나는 숫자나 막대의 두께(갯수) 등을 언급하라.
1. 선택 정렬 => 비교횟수 7875회, 데이터 접근횟수 15526회, 걸린 시간 7.9ms
2. 삽입 정렬  => 비교횟수 17119회, 데이터 접근횟수 51116회, 걸린 시간 4.0ms
3. 퀵 정렬 => 비교횟수 16721회, 데이터 접근횟수 24113회, 걸린 시간 0.79ms
4.  병합 정렬 => 비교횟수 5057회, 데이터 접근횟수 16509회, 걸린 시간 1.6ms
5. 힙 정렬 => 비교횟수 9832회, 데이터 접근횟수 30335회, 걸린 시간 1.6ms
6. 기수 정렬(LSD) => 비교횟수 0회, 데이터 접근횟수 6300회, 걸린 시간 1.6ms
7. 기수 정렬(MSD) => 비교횟수 0회, 데이터 접근횟수 9441회, 걸린 시간 1.6ms
8. 표준 정렬 => 비교횟수 16821회, 데이터 접근횟수 28348회, 걸린 시간 0.79ms
9. std::stable_sort => 비교횟수 12337회, 데이터 접근횟수 29046회, 걸린 시간 0.79ms
10. 셸 정렬 => 비교횟수 7757회, 데이터 접근횟수 19675회, 걸린 시간 1.6ms
11. 버블 정렬 => 비교횟수 7875회, 데이터 접근횟수 24761회, 걸린 시간 7.9ms
12. 칵테일 셰이커 정렬 => 비교횟수 5531회, 데이터 접근횟수 16438회, 걸린 시간 0.75ms
13. 그놈 정렬 => 비교횟수 8855회, 데이터 접근횟수 21960회, 걸린 시간 7.9ms
14. 바이토닉 정렬 =>비교횟수 14245회, 데이터 접근횟수 42435회, 걸린 시간 1.6ms
15 보고 정렬 => 비교횟수 ???, 데이터 접근횟수 ???회, 걸린 시간 ???

막대길이가 길수록 데이터크기가 큰거고 데이터너비가 클수록 데이터 개수가 적은것이다. 빨간색막대는 서로 스왑되는 막대들을 나타내는 것이다.


4. 한붓그리기가 가능한 경우와 불가능한 경우는 무엇을 보고 말할 수 있는가?
꼭짓점 차수가 모두 짝수 이거나 꼭짓점 차수가 홀수인 꼭짓점이 2개뿐일떄를 제외하고는 모든 그림들이 한붓그리기가 불가능하다.
