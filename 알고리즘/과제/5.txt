[필수사항]

https://www.youtube.com/watch?v=QAyl79dCO_k
의 내용을 정리한다.

merge sort	
정렬되지 않은 배열을 데이터가 2개씩 남을때까지 나누어 각각을 정렬을 한 후 
다시 다른 배열과 비교하여 정렬하면서 새로운 배열을 만드는 것을 계속 하여 반복하는 방법.
데이터 개수 n개, log n번 돌기 때문에 시간복잡도는 O(n log n)을 가진다. 
ex) {7,6,5,8} => {7,6},{5,8} => {6,7},{5,8} => {6} > {5} = {5}, {6} < {8} = {5,6}, {7} < {8} = {5,6,7}, {NULL} {8} = {5,6,7,8}

과

https://www.youtube.com/watch?v=7BDzle2n47c&t=517s

의 내용을 정리한다.
랜덤으로 값을 잡고 이 값보다 작은거는 왼쪽, 큰 거는 오른쪽으로 잡는다. 그 후 작은거 그리고 큰 거에서 또 데이터를 잡고 작은거에서 잡은 데이터보다 작은거는 왼쪽 큰거는 오른쪽으로 나누는 것을 반복한다.
평균적으로 O(n log n)이고 최악의 경우에는 O(n^2)까지 나온다.
이 때 값을 정하는 거는 pivot라고 한다. 정렬되지 않는 데이터의 경우 보통 가운데에 있는 데이터를 pivot으로 잡는데
이때, pivot가 비교적 낮은 값에 해당하는 값이면 정렬해야 되는 데이터 량이 줄지 않기 때문에 이 경우가 반복하면 최악의 경우가 나온다.
퀵정렬의 알고리즘은 pivot값을 정하고 start,end을 지정후 start가 pivot값보다 크면 멈춘 후 end가 출발하는데, pivot값보다 크면 start와 end를 맞바꾼다.
그리고 start와 end가 위치가 역전되면 다시 pivot값을 큰 쪽과 작은 쪽에서 잡고 위 알고리즘을 돌린다. 이때 큰 쪽이나 작은 쪽이 1개가 남으면 그쪽으로는 더이상 진행하지 않는다.

[참고사항]

MergeSort 의 경우

https://www.youtube.com/watch?v=FCAtxryNgq4
분할정복 알고리즘 모든 배열을 나눈 뒤 정렬 후 병합하는 알고리즘.
재귀함수로 분할 부분을 만들고. 왼쪽이 오른쪽 좌표보다 작으면 if문안쪽을 돌게 만든다.
이후 미드값을 구한 후 재귀함수를 다시 부르는데 이때 (레프트값,미들값) 과 (미드값+1,라이트값)을 매개변수값으로 넘겨준다.
그리고 merge함수(정복)을 부르는데 여기서 정렬을 하면서 병합 하게 된다.
시간복잡도는 모든 케이스는 O(n log n)이다.


https://www.youtube.com/watch?v=ctkuGoJPmAE
를 참고해도 좋다.
분할정복 방법으로 정확히 반절씩 나눈다는 점에서 모든 경우에서 O(n log n)이 나온다.
퀵 정렬과 다르게 피벗 값이 없이 항상 반절씩 나누고 정렬후 병합을 반복하는 정렬방법이다.



QuickSort 의 경우 역시

https://www.youtube.com/watch?v=cWH49IKDIiI
분할 정복 알고리즘은로 pivot을 정한 뒤 pivot의 위치를 확정해가며 정렬하는 알고리즘
pivot을 어떻게 선정하는지에 따라 걸리는 시간이 달라진다. 보통은 데이터의 중앙을 잡는다.


